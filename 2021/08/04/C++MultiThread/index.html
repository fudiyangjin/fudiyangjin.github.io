<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="C++多线程介绍及其API函数">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程与资源同步">
<meta property="og:url" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/index.html">
<meta property="og:site_name" content="fudiyangjin">
<meta property="og:description" content="C++多线程介绍及其API函数">
<meta property="og:locale">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/.thread1.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/thread2.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/thread3.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/Untitled.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/thread4.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/thread5.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/thread6.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/thread7.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/(1).png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/(2).png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/(3).png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/1.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/2.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/4.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E9%80%BB%E8%BE%91%E5%9B%BE.jpg">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/5.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/6.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/7.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/8.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/9.png">
<meta property="og:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/%E5%A4%9A%E7%BA%BF%E7%A8%8B-1.png">
<meta property="article:published_time" content="2021-08-04T10:54:48.000Z">
<meta property="article:modified_time" content="2021-08-04T11:00:54.749Z">
<meta property="article:author" content="巨鹏辉">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/.thread1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/"/>





  <title>多线程与资源同步 | fudiyangjin</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fudiyangjin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fudiyangjin.github.io/2021/08/04/C++MultiThread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fudiyangjin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">多线程与资源同步</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-04T18:54:48+08:00">
                2021-08-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-08-04T19:00:54+08:00">
                2021-08-04
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>C++多线程介绍及其API函数</p>
<span id="more"></span>

<h1 id="线程、进程基本概念"><a href="#线程、进程基本概念" class="headerlink" title="线程、进程基本概念"></a>线程、进程基本概念</h1><p>一个进程代表计算机中实际运行的一个程序，并且每个进程都有自己独立的进程地址空间和上下文堆栈，就一个程序本身执行的操作而言，进程不执行任何进程代码，只提供一个大环境容器，进程中实际执行程序的是线程。因此一个进程中至少有一个线程。</p>
<p>线程是进程中实际执行代码的最小单元，由操作系统安排调度。</p>
<h1 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h1><h2 id="创建线程（Linux）"><a href="#创建线程（Linux）" class="headerlink" title="创建线程（Linux）"></a>创建线程（Linux）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> * attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">//attr指定了线程的属性，一般被设为NULL</span></span><br><span class="line"><span class="comment">//参数start_routine指定了线程函数</span></span><br><span class="line"><span class="comment">//参数arg用于在创建线程时将某个参数传入线程函数中</span></span><br><span class="line"><span class="comment">//返回值：成功返回0，失败返回错误码</span></span><br></pre></td></tr></table></figure>

<p>参数thread是一个输出参数，如果线程创建成功，则通过这个函数就可以得到创建成功的线程ID</p>
<h2 id="创建线程（Windows）"><a href="#创建线程（Windows）" class="headerlink" title="创建线程（Windows）"></a>创建线程（Windows）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">LPSECURITY_ATTRIBUTES                  lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T                                 dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">LPTHREAD_START_ROUTINE                 lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID                                 lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD                                  dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">LPDWORD                                lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//lpThreadAttributes表示线程的安全属性，一般设置为NULL</span></span><br><span class="line"><span class="comment">//dwStackSize指线程的栈空间大小，一般被指定为0</span></span><br><span class="line"><span class="comment">//lpStartAddress为线程函数，函数指针类型，定义如下:</span></span><br><span class="line"><span class="comment">//typedef DWORD (__stdcall *LPTHREAD_START_ROUTINE)(LPVOID lpThreadParameter);</span></span><br><span class="line"><span class="comment">//lpParameter是传给线程函数的参数</span></span><br><span class="line"><span class="comment">//dwCreationFlags是一个32位的无符号整形（DWORD），一般被设为0</span></span><br><span class="line"><span class="comment">//lpThreadId表示线程创建成功时返回的线程ID，也表示一个32位无符号整形DWORD的指针</span></span><br><span class="line"><span class="comment">//成功创建则返回线程的句柄，否则返回NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A New Thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwThreadID;</span><br><span class="line">	HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line">	<span class="keyword">if</span> (hThread == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error CreateThread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src=".thread1.png" alt="thread1"></p>
<h2 id="创建线程（Windows-CRT）"><a href="#创建线程（Windows-CRT）" class="headerlink" title="创建线程（Windows CRT）"></a>创建线程（Windows CRT）</h2><p>CRT是C函数库，实际开发推荐，而不是CreateThread函数</p>
<p>Windows C库创建线程时常用的函数是_beginthreadex，其声明位于process.h头文件中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> _beginthreadex</span><br><span class="line">  <span class="keyword">void</span> *security,</span><br><span class="line">  <span class="built_in"><span class="keyword">unsigned</span></span> ( __stdcall *start_address )( <span class="keyword">void</span> * ),</span><br><span class="line">  <span class="keyword">void</span> *arglist,</span><br><span class="line">  <span class="keyword">unsigned</span> initflag,</span><br><span class="line">  <span class="keyword">unsigned</span> *thrdaddr</span><br><span class="line">);</span><br><span class="line"><span class="comment">//API参数与CreateThread基本一致</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> __stdcall <span class="title">threadfun</span><span class="params">(<span class="keyword">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;NEW Thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> threadid;</span><br><span class="line">	_beginthreadex(<span class="number">0</span>, <span class="number">0</span>, threadfun, <span class="number">0</span>, <span class="number">0</span>, &amp;threadid);</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./thread2.png" alt="thread2"></p>
<h2 id="创建线程（std-thread"><a href="#创建线程（std-thread" class="headerlink" title="创建线程（std::thread)"></a>创建线程（std::thread)</h2><p>C++11新标准引入了一个新的类std::thread，使用这个类可以将任意签名形式的函数作为线程函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadproc1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;New Thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadproc2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;New Thread2!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(threadproc1)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(threadproc2, <span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::thread 在运行期间必须是有效的。</span></span><br></pre></td></tr></table></figure>

<p><img src="./thread3.png" alt="thread3"></p>
<p>thread在运行间必须是有效的，因此在使用上也容易出错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadproc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;New Thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(threadproc)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./Untitled.png" alt="Untitled"></p>
<p>func()函数创建了一个线程，在func函数调用结束后，func中的局部变量t被销毁，但此时线程函数仍然在运行，使用在使用std::thread类时必须保证在运行时其线程对象有效。利用detach可以使线程对象与线程函数脱离关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">std::thread <span class="title">t</span><span class="params">(threadproc)</span></span>;</span><br><span class="line">   t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开发过程中，可能需要使用线程对象去控制和管理线程的运行和生命周期，因此代码应该尽量保证线程对象在线程运行期间有效，而不是单纯地调用detach方法使线程对象与线程函数的运行分离。</p>
<h2 id="获取线程ID"><a href="#获取线程ID" class="headerlink" title="获取线程ID"></a>获取线程ID</h2><p>在创建成功线程后，可以得到一个线程ID。线程ID是唯一的，因此可以拿来标识和区分线程。在Linux上调用pthread_self函数获取线程ID，在Windows上调用GeturrentThreadID函数获取。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">GetCurrentThreadiD</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>pthread_t和DWORD 在本质上都是32位无符号整型。</p>
<ul>
<li>Linux系统线程ID的本质</li>
</ul>
<p>方法1：调用pthread_create函数时通过第一个参数可以得到线程ID：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thread_proc, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>方法2：在需要获取ID的线程中调用pthread_self函数获取</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_t</span> tid = <span class="built_in">pthread_self</span>();</span><br></pre></td></tr></table></figure>

<p>方法3：通过系统调用获取线程ID</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> tid = <span class="built_in">syscall</span>(SYS_gettid);</span><br></pre></td></tr></table></figure>

<p>方法一和方法二获取线程ID的结果是一样的，都是pthread_t类型，输出的是一块内存空间地址。由于不同的进程可能有同样地址的内存块，因此方法1方法2获取的线程ID可能不是全系统唯一的，一般是一个很大的数字。方法3获得的线程ID是全系统内唯一的，一般是个不太大的整数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_proc</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span>* tid1 = (<span class="keyword">pthread_t</span>*)arg;</span><br><span class="line">	<span class="keyword">int</span> tid2 = <span class="built_in">syscall</span>(SYS_gettid);</span><br><span class="line">	<span class="keyword">pthread_t</span> tid3 = <span class="built_in">pthread_self</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;tid1: &quot;</span> &lt;&lt; *tid1 &lt;&lt; <span class="string">&quot;  tid2: &quot;</span> </span><br><span class="line">			&lt;&lt; tid2 &lt;&lt; <span class="string">&quot;  tid3: &quot;</span> &lt;&lt; tid3 &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, thread_proc, &amp;tid);</span><br><span class="line">	<span class="built_in">pthread_join</span>(tid, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./thread4.png" alt="thread4"></p>
<ul>
<li><strong>C++11 获取当前线程ID的方法</strong></li>
</ul>
<p>C++11的线程库可以使用std::this_thread类的get_id获取当前线程ID</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker_thread_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(worker_thread_func)</span></span>;</span><br><span class="line">	std::thread::id worker_thread_id = t.<span class="built_in">get_id</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;worker thread id:&quot;</span> &lt;&lt; worker_thread_id &lt;&lt; std::endl;</span><br><span class="line">	std::thread::id main_thread_id = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">	std::ostringstream oss;</span><br><span class="line">	oss &lt;&lt; main_thread_id;</span><br><span class="line">	std::string str = oss.<span class="built_in">str</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;main thread id: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> threadid = std::<span class="built_in">stoull</span>(str);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;main thread id: &quot;</span> &lt;&lt; threadid &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./thread5.png" alt="thread5"></p>
<h2 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h2><ul>
<li>在Linux下等待线程结束</li>
</ul>
<p>//TODO     补充</p>
<ul>
<li>在Windows下等待线程结束</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_FILENAME <span class="meta-string">&quot;time.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">FileThreadFunc</span><span class="params">(LPVOID lpParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">tm</span>* <span class="title">t</span> =</span> <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">	<span class="keyword">char</span> timeStr[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">sprintf_s</span>(timeStr, <span class="number">32</span>, <span class="string">&quot;%04d/%02d/%02d %02d:%02d:%02d&quot;</span>,</span><br><span class="line">		t-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">		t-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">		t-&gt;tm_mday,</span><br><span class="line">		t-&gt;tm_hour,</span><br><span class="line">		t-&gt;tm_min,</span><br><span class="line">		t-&gt;tm_sec);</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(TIME_FILENAME, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to create time.txt.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">size_t</span> sizeToWrite = <span class="built_in">strlen</span>(timeStr) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">size_t</span> ret = <span class="built_in">fwrite</span>(timeStr, <span class="number">1</span>, sizeToWrite, fp);</span><br><span class="line">	<span class="keyword">if</span> (ret != sizeToWrite)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Write file error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwFileThreadID;</span><br><span class="line">	HANDLE hFileThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, FileThreadFunc, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">		&amp;dwFileThreadID);</span><br><span class="line">	<span class="keyword">if</span> (hFileThread == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to create fileThread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hFileThread, INFINITE);</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(TIME_FILENAME, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;open file error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> sizeRead = <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">32</span>, fp);</span><br><span class="line">	<span class="keyword">if</span> (sizeRead == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;read file error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">fclose</span>(fp);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Current Time is:&quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./thread6.png" alt="thread6"></p>
<ul>
<li>C++11等待线程结束</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_FILENAME <span class="meta-string">&quot;time.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">FileThreadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">tm</span>* <span class="title">t</span> =</span> <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">	<span class="keyword">char</span> timeStr[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">sprintf_s</span>(timeStr, <span class="number">32</span>, <span class="string">&quot;%04d/%02d/%02d %02d:%02d:%02d&quot;</span>,</span><br><span class="line">		t-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">		t-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">		t-&gt;tm_mday,</span><br><span class="line">		t-&gt;tm_hour,</span><br><span class="line">		t-&gt;tm_min,</span><br><span class="line">		t-&gt;tm_sec);</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(TIME_FILENAME, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to create time.txt.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">size_t</span> sizeToWrite = <span class="built_in">strlen</span>(timeStr) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">size_t</span> ret = <span class="built_in">fwrite</span>(timeStr, <span class="number">1</span>, sizeToWrite, fp);</span><br><span class="line">	<span class="keyword">if</span> (ret != sizeToWrite)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Write file error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(FileThreadFunc)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (t.<span class="built_in">joinable</span>())</span><br><span class="line">		t.<span class="built_in">join</span>();</span><br><span class="line">	FILE* fp = <span class="built_in">fopen</span>(TIME_FILENAME, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;open file error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> sizeRead = <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">32</span>, fp);</span><br><span class="line">	<span class="keyword">if</span> (sizeRead == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;read file error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">fclose</span>(fp);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Current Time is:&quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对象实例指针作为线程函数的参数"><a href="#对象实例指针作为线程函数的参数" class="headerlink" title="对象实例指针作为线程函数的参数"></a>对象实例指针作为线程函数的参数</h1><p>除了C++11线程库中的std::thread对函数签名没有特殊要求外，无论是Linux还是Windows的线程函数签名都必须是指定的格式。如果对线程函数进行封装，线程函数就不能是类的实例的方法，必须是类的静态方法。以Linux的线程函数签名为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>将线程的基本功能封装到一个Thread类中，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Thread</span>();</span><br><span class="line">   ~<span class="built_in">Thread</span>();</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>threadFunc是一个类实例方法，编译器在编译时会把这些函数“翻译”成全局函数，即去掉类的域限制。为了保证类方法的正常功能，编译器在翻译时会将类的实例对象地址作为第一个参数传入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(Thread* <span class="keyword">this</span>, <span class="keyword">void</span>* arg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这样的话不符合线程函数的签名要求，因此如果类方法作为线程函数，则只能是类的静态方法，不能是类的实例方法。C++11中的std::thread类就没有这个限制，但是必须显式地将线程函数所属的类对象实例指针和this指针传递给std::thread</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Thread</span>()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Thread</span>()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_stopped = <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//theadFunc是类的非静态方法，作为线程函数第一个参数必须传递类实例的地址</span></span><br><span class="line">		m_spThread.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(&amp;Thread::threadFunc, <span class="keyword">this</span>, <span class="number">8888</span>, <span class="number">9999</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_stopped = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (m_spThread)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (m_spThread-&gt;<span class="built_in">joinable</span>())</span><br><span class="line">				m_spThread-&gt;<span class="built_in">join</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">threadFunc</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!m_stopped)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Thread funcion use instance method&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::shared_ptr&lt;std::thread&gt; m_spThread;</span><br><span class="line"><span class="comment">//智能指针std::shared_ptr包裹了std::thread对象，不需要手动删除std::thread对象了。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> m_stopped;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Thread mythread;</span><br><span class="line">	mythread.<span class="built_in">Start</span>();</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./thread7.png" alt="thread7"></p>
<h1 id="整型变量的原子操作"><a href="#整型变量的原子操作" class="headerlink" title="整型变量的原子操作"></a>整型变量的原子操作</h1><p>线程同步技术，指的是多个线程同时操作某个资源，为了防止一些资源的访问冲突，应该采取一系列的措施。最简单的资源类型就是整型变量。</p>
<h2 id="原子操作与整型变量的赋值"><a href="#原子操作与整型变量的赋值" class="headerlink" title="原子操作与整型变量的赋值"></a>原子操作与整型变量的赋值</h2><ul>
<li><strong>给整型变量赋予一个确定的值</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这条指令一般是原子的，因为仅对应一条计算机指令，但是由于现代编译器的优化策略，当变量的值在编译期间可以被计算出来时，就很有可能被优化，凡是用到a的地方直接用常量1来替代。</p>
<ul>
<li><strong>变量自身增加或减去一个值</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a++;</span><br></pre></td></tr></table></figure>

<p>对应汇编有三条指令，首先将a对应的内存值移动到寄存器中，寄存器中的值自增1，再从寄存器移回来</p>
<ul>
<li><strong>把变量的值赋给另一个变量</strong></li>
</ul>
<p>对应汇编有2条指令，首先将变量b的值搬运到某个寄存器中，再从该寄存器中搬运变量a到内存中。</p>
<h2 id="C-11对整型变量原子操作的支持"><a href="#C-11对整型变量原子操作的支持" class="headerlink" title="C++11对整型变量原子操作的支持"></a>C++11对整型变量原子操作的支持</h2><p>C++11提供了对整型变量原子操作的相关库，即std::atomic</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::atomic&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line">	value = <span class="number">99</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in"><span class="keyword">int</span></span>(value) &lt;&lt; std::endl;</span><br><span class="line">	value++;</span><br><span class="line">	std::cout &lt;&lt; (<span class="keyword">int</span>)value &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Linux线程同步对象"><a href="#Linux线程同步对象" class="headerlink" title="Linux线程同步对象"></a>Linux线程同步对象</h1><h2 id="Linux互斥体"><a href="#Linux互斥体" class="headerlink" title="Linux互斥体"></a>Linux互斥体</h2><p>Linux互斥体是通过多个线程同时执行某段代码来保护资源的。Linux互斥体在NPTL（Native POSIX Thread LIbrary中实现。在NPTL中使用数据结构pthread_mutex_t表示一个互斥体对象，并且可以使用以下两种方式初始化互斥体对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mymutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>互斥体初始化函数如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(pthread_mutex_* <span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span>* <span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">//参数mutex需要初始化MUTEX对象指针</span></span><br><span class="line"><span class="comment">//参数attr是需要设置的互斥体属性，通常设置为NULL</span></span><br><span class="line"><span class="comment">//执行成功返回0，失败返回1个错误码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mymutex;</span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mymutex, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>当不需要一个互斥体对象时，可以使用pthread_mutex_destroy 函数销毁它，pthread_mutex_destroy签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="comment">//参数mutex是需要销毁的互斥体对象</span></span><br><span class="line"><span class="comment">//执行成功返回0，执行失败返回一个错误码表面出错的原因</span></span><br><span class="line"><span class="comment">//注意：无须销毁使用PTHREAD_MUTEX_INITALIZER初始化的互斥体</span></span><br><span class="line"><span class="comment">//      不要销毁一个已经加锁或正在被条件变量使用的互斥体对象，当互斥体处于已加锁状态或者</span></span><br><span class="line"><span class="comment">//正在和条件变量配合使用时，调用pthread_mutex_destroy函数会返回EBUSY错误</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_mutex_t</span> mymutex;</span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mymutex, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">pthread_mutex_destroy</span>(&amp;mymutex);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;EBUSY&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to destroy mutex&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">pthread_mutex_unlock</span>(&amp;mymutex);</span><br><span class="line">	ret = <span class="built_in">pthread_mutex_destroy</span>(&amp;mymutex);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Succeeded to destroy mutex&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Linux上编译以上代码并执行:</p>
<p><img src="./(1).png" alt="(1)"></p>
<p>在开发过程中，应创建互斥体对象后再对其加锁，加锁后才对其进行解锁操作，解锁后才进行销毁操作，那么编码时一般不用考虑pthread_mutex_init/pthread_mutex_destroy/pthread_mutex_lock/pread_mutex_unlock等函数的返回值。</p>
<p>对于互斥体的加锁和解锁，一般用以下三个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="comment">//参数mutex是需要加锁或解锁的对象</span></span><br><span class="line"><span class="comment">//成功执行返回0，执行失败返回一个错误码表示错误原因</span></span><br></pre></td></tr></table></figure>

<p>设置互斥体对象的属性时需要创建一个pthread_mutexattr_t类型的对象，并用pthread_mutexattr_init函数初始化它，最后用pthread_mutexattr_destroy销毁它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span>* attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span>* attr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用pthread_mutexattr_settype/pthread_mutexattr_gettype 设置或或得想要的属性类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span>* attr, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_gettype</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span>* <span class="keyword">restrict</span> attr, <span class="keyword">int</span>* <span class="keyword">restrict</span> type)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>PTHREAD_MUTEX_NORMAL(普通锁)</strong></li>
</ul>
<p>互斥体对象的默认属性，即pthread_mutex_init函数的第2个参数设置为NULL的取值。在一个进程对一个普通锁加锁以后，其他线程会阻塞在pthread_mutex_lock调用处直到对互斥体加锁的线程释放了锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mymutex;</span><br><span class="line"><span class="keyword">int</span> resourceNo = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">worker_thread</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> threadID = <span class="built_in">pthread_self</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;thread start, ThreadID : &quot;</span> &lt;&lt; threadID &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Mutex lock, resourceNo: &quot;</span></span><br><span class="line">			&lt;&lt; resourceNo &lt;&lt; <span class="string">&quot;THreadID:&quot;</span> &lt;&lt; threadID &lt;&lt; std::endl;</span><br><span class="line">		resourceNo++;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Mutex unlock, resourceNo:&quot;</span></span><br><span class="line">			&lt;&lt; resourceNo &lt;&lt; <span class="string">&quot;ThreadID:&quot;</span> &lt;&lt; threadID &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mymutex);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_mutexattr_t</span> mutex_attr;</span><br><span class="line">	<span class="built_in">pthread_mutexattr_init</span>(&amp;mutex_attr);</span><br><span class="line">	<span class="built_in">pthread_mutexattr_settype</span>(&amp;mutex_attr, PTHREAD_MUTEX_NORMAL);</span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mymutex, &amp;mutex_attr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_t</span> threadID[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="built_in">pthread_create</span>(&amp;threadID[i], <span class="literal">NULL</span>, worker_thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="built_in">pthread_join</span>(threadID[i], <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mymutex);</span><br><span class="line">	<span class="built_in">pthread_mutexattr_destroy</span>(&amp;mutex_attr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./(2).png" alt="(2)"></p>
<p>代码创建了5个线程，由于使用了互斥体保护资源resourceNo，所以pthread_mutex_lock与pthread_mutex_unlock之间的输出每次都是连续的，一个线程完成了这个工作后其他线程才有获得执行这段代码的机会，在一个线程拿到锁之后，其他线程会阻塞在pthread_mutex_lock处。</p>
<p>如果对一个已经加锁的普通锁再次使用了pthread_mutex_lock加锁那么程序会阻塞在第2次调用pthread_mutex_lock代码处</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mymutex;</span><br><span class="line"><span class="keyword">int</span> resourceNo = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">worker_thread</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> threadID = <span class="built_in">pthread_self</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;thread start, ThreadID : &quot;</span> &lt;&lt; threadID &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Mutex lock, resourceNo: &quot;</span></span><br><span class="line">			&lt;&lt; resourceNo &lt;&lt; <span class="string">&quot;THreadID:&quot;</span> &lt;&lt; threadID &lt;&lt; std::endl;</span><br><span class="line">		resourceNo++;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Mutex unlock, resourceNo:&quot;</span></span><br><span class="line">			&lt;&lt; resourceNo &lt;&lt; <span class="string">&quot;ThreadID:&quot;</span> &lt;&lt; threadID &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mymutex);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_mutex_t</span> mymutex;</span><br><span class="line">	<span class="keyword">pthread_mutexattr_t</span> mutex_attr;</span><br><span class="line">	<span class="built_in">pthread_mutexattr_init</span>(&amp;mutex_attr);</span><br><span class="line">	<span class="built_in">pthread_mutexattr_settype</span>(&amp;mutex_attr, PTHREAD_MUTEX_NORMAL);</span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mymutex, &amp;mutex_attr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ret: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ret: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mymutex);</span><br><span class="line">	<span class="built_in">pthread_mutexattr_destroy</span>(&amp;mutex_attr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用gdb做如下调试</p>
<p><img src="./(3).png" alt="(3)"></p>
<p>程序只运行了一行并且使用bt指令发现确实阻塞在第2个pthread_mutex_lock函数调用处，pthread_mutex_trylock函数如果拿不到锁，则也不会阻塞，而是会返回EBUSY错误码。</p>
<ul>
<li><strong>PTHREAD_MUTEX_ERRORCHECK（检错锁）</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_mutex_t</span> mymutex;</span><br><span class="line">	<span class="keyword">pthread_mutexattr_t</span> mutex_attr;</span><br><span class="line">	<span class="built_in">pthread_mutexattr_init</span>(&amp;mutex_attr);</span><br><span class="line">	<span class="built_in">pthread_mutexattr_settype</span>(&amp;mutex_attr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mymutex, &amp;mutex_attr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ret: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">	ret = <span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ret: &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">if</span> (ret == EDEADLK)</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;EDEADLK&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mymutex);</span><br><span class="line">	<span class="built_in">pthread_mutexattr_destroy</span>(&amp;mutex_attr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./1.png" alt="1"></p>
<p>当前线程利用pthread_mutex_lock对已加锁的互斥体对象再次加锁则pthread_mutex_lock会返回EDEADLK</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mymutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">worker_thread</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> threadID = <span class="built_in">pthread_self</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;thread start, ThreadID: &quot;</span> &lt;&lt; threadID &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ret = <span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line">		<span class="keyword">if</span> (ret == EDEADLK)</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;EDEADLK, ThreadID: &quot;</span> &lt;&lt; threadID &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;ThreadID:&quot;</span> &lt;&lt; threadID;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_mutexattr_t</span> mutex_attr;</span><br><span class="line">	<span class="built_in">pthread_mutexattr_init</span>(&amp;mutex_attr);</span><br><span class="line">	<span class="built_in">pthread_mutexattr_settype</span>(&amp;mutex_attr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mymutex, &amp;mutex_attr);</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ret&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">pthread_t</span> threadID[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="built_in">pthread_create</span>(&amp;threadID[i], <span class="literal">NULL</span>, worker_thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="built_in">pthread_join</span>(threadID[i], <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mymutex);</span><br><span class="line">	<span class="built_in">pthread_mutexattr_destroy</span>(&amp;mutex_attr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./2.png" alt="2"></p>
<p>一个线程对某个互斥体加锁，其他线程再次对该互斥体加锁，gdb运行后发现没有输出，中断后发现线程均被阻塞在pthread_mutex_lock调用处。</p>
<ul>
<li><strong>PTHREAD_MUTEX_RECURSIVE(可重入锁)</strong></li>
</ul>
<p>PTHREAD_MUTEX_RECURSIVE允许同一线程对其持有的互斥体重复加锁，每次成功调用pthread_mutex_lock一次，该互斥体对象的锁引用就会增加1，每次成功调用pthread_mutex_unlock一次，锁引用计数就会减1。当引用值为0时允许其他线程获得该锁，否则其他线程在执行pthread_mutex_lock时会被阻塞在pthreadmutex_lock处</p>
<h2 id="Linux信号量"><a href="#Linux信号量" class="headerlink" title="Linux信号量"></a>Linux信号量</h2><p>信号量代表一定的资源数量，可以根据当前资源数量按需唤醒指定数量的资源消费者线程，资源消费者线程一旦获取信息量，就会让资源减少对应的数量。Linux信号量常用的API如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>* sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="comment">//初始化函数，第1个参数sem传入需要初始化的信号量对象的地址。</span></span><br><span class="line"><span class="comment">//第2个参数pshared取值为0表示只能在同进程多线程之间共享，非0表示可以在多个进程之间共享。</span></span><br><span class="line"><span class="comment">//第3个参数value用于设置信号量初始状态下的资源数量。</span></span><br><span class="line"><span class="comment">//成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>;</span><br><span class="line"><span class="comment">//销毁信号量函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>;</span><br><span class="line"><span class="comment">//信号量资源计数递增1，并解锁该信号量对象，这样因使用sem_wait函数被阻塞的其他线程会被唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>;</span><br><span class="line"><span class="comment">//如果当前信号量的资源计数为0，则函数会阻塞调用线程；信号量资源大于0时被唤醒，资源计数-1，立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span>* sem)</span></span>;</span><br><span class="line"><span class="comment">//当前信号量资源计数等于0，函数立即返回，并且不会阻塞调用线程，返回值为-1，错误码为EAGAIN</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="keyword">sem_t</span>* sem, <span class="keyword">const</span> struct timespec* abs_timeout)</span></span>;</span><br><span class="line"><span class="comment">//abs_timeout参数设置的时间内等待信号量对象的资源计数大于0，否则超时返回，返回值为-1，错误码ETIMEDOUT</span></span><br><span class="line"><span class="comment">//结构体定义：struct timespec</span></span><br><span class="line"><span class="comment">//           &#123;</span></span><br><span class="line"><span class="comment">//               time_t tv_sec;  秒</span></span><br><span class="line"><span class="comment">//               long tv_nsec;   纳秒</span></span><br><span class="line"><span class="comment">//           &#125;;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Task</span>(<span class="keyword">int</span> taskID)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;taskID == taskID;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;handle a task, taskID: &quot;</span> &lt;&lt; taskID</span><br><span class="line">			&lt;&lt; <span class="string">&quot;, threadID: &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> taskID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mymutex;</span><br><span class="line">std::list&lt;Task*&gt; tasks;</span><br><span class="line"><span class="keyword">sem_t</span> mysemaphore;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer_thread</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Task* pTask = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">sem_wait</span>(&amp;mysemaphore) != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (tasks.<span class="built_in">empty</span>())</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line">		pTask = tasks.<span class="built_in">front</span>();</span><br><span class="line">		tasks.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mymutex);</span><br><span class="line">		pTask-&gt;<span class="built_in">doTask</span>();</span><br><span class="line">		<span class="keyword">delete</span> pTask;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer_thread</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> taskID = <span class="number">0</span>;</span><br><span class="line">	Task* pTask = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pTask = <span class="keyword">new</span> <span class="built_in">Task</span>(taskID);</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line">		tasks.<span class="built_in">push_back</span>(pTask);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;produce a task, taskID: &quot;</span> &lt;&lt; taskID &lt;&lt; <span class="string">&quot;, threadID: &quot;</span></span><br><span class="line">			&lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mymutex);</span><br><span class="line">		<span class="built_in">sem_post</span>(&amp;mysemaphore);</span><br><span class="line">		taskID++;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mymutex, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">sem_init</span>(&amp;mysemaphore, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> consumerThreadID[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="built_in">pthread_create</span>(&amp;consumerThreadID[i], <span class="literal">NULL</span>, consumer_thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> producerThreadID;</span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;producerThreadID, <span class="literal">NULL</span>, producer_thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_join</span>(producerThreadID, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="built_in">pthread_join</span>(consumerThreadID[i], <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">sem_destroy</span>(&amp;mysemaphore);</span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mymutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./4.png" alt="4"></p>
<p>创建了一个生产者线程和5给个消费者线程，初始信号量计数为0表示一开始没有可执行任务，所以5个消费者线程均被阻塞在sem_wait调用处。接着生产者每隔1s产生1个任务，通过sem_post将资源计数增1唤醒其中一个线程。代码中的互斥体是为了保护队列tasks，因为多个线程会同时读写它。信息量有sem_wait和sem_post加锁和解锁。</p>
<h2 id="Linux条件变量"><a href="#Linux条件变量" class="headerlink" title="Linux条件变量"></a>Linux条件变量</h2><ul>
<li><strong>条件变量的基本使用逻辑</strong></li>
</ul>
<p><img src="./%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E9%80%BB%E8%BE%91%E5%9B%BE.jpg" alt="条件变量逻辑图"></p>
<p>利用条件等待机制可以高效完成：某个线程A在条件不满足的情况下主动让出互斥体，让其他线程操作，线程A等待条件满足；条件满足后，线程A被立即唤醒。</p>
<ul>
<li><strong>条件变量与互斥体对象</strong></li>
</ul>
<p>条件变量与互斥体要结合使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//m的类型是pthread_mutex_t,并且已经初始化,cv是条件变量</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;m)</span><br><span class="line"><span class="keyword">while</span>(condition_is_false)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">pthread_mutex_unlock</span>(&amp;m);</span><br><span class="line"><span class="comment">//解锁之后，等待之前，可能条件已经满足，信号已经发出，但是该信号可能被错过</span></span><br><span class="line">   <span class="built_in">cond_wait</span>(&amp;cv);</span><br><span class="line">   <span class="built_in">pthread_mutex_lock</span>(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设线程A执行完pthread_mutex_unlock(&amp;m)后CPU时间片被剥夺，此时另一个线程B获得该互斥体对象m，发送条件信号，等线程A重新获得时间片后，由于该信号已经被错过，可能会导致线程A在cond_wait(&amp;cv)无线阻塞。因此条件变量应与互斥体结合。</p>
<ul>
<li><strong>条件变量的使用</strong></li>
</ul>
<p>条件变量的API函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span>* attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond)</span></span>;</span><br><span class="line"><span class="comment">//pthread_cond_t表示条件变量的数据类型，也可以使用下面这行语句初始化一个条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>等待条件变量被唤醒API函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="comment">//如果条件变量等待的条件没有被满足，则调用后线程会一直等待下去</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span>* </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">restrict</span> mutex, <span class="keyword">const</span> struct timespec* <span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="comment">//是pthread_cond_wait的非阻塞版本，它会在指定的时间内等待条件满足，超过abstime设置的时间后，函数会立即返回</span></span><br></pre></td></tr></table></figure>

<p>等待的线程可被以下API函数唤醒</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="comment">//一次唤醒一个线程，但如果有多个线程调用pthread_cond_wait等待，则唤醒的线程是随机的，成功返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span>* </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">restrict</span> mutex, <span class="keyword">const</span> struct timespec* <span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="comment">//同时唤醒所有调用pthread_cond_wait等待的线程，成功返回0，失败返回错误码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Task</span>(<span class="keyword">int</span> taskID)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;taskID == taskID;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;handle a task, taskID: &quot;</span> &lt;&lt; taskID</span><br><span class="line">			&lt;&lt; <span class="string">&quot;, threadID: &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> taskID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mymutex;</span><br><span class="line">std::list&lt;Task*&gt; tasks;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> mycv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer_thread</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Task* pTask = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line">		<span class="keyword">while</span> (tasks.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">pthread_cond_wait</span>(&amp;mycv, &amp;mymutex);</span><br><span class="line">		&#125;</span><br><span class="line">		pTask = tasks.<span class="built_in">front</span>();</span><br><span class="line">		tasks.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mymutex);</span><br><span class="line">		<span class="keyword">if</span> (pTask == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		pTask-&gt;<span class="built_in">doTask</span>();</span><br><span class="line">		<span class="keyword">delete</span> pTask;</span><br><span class="line">		pTask = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer_thread</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> taskID = <span class="number">0</span>;</span><br><span class="line">	Task* pTask = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pTask = <span class="keyword">new</span> <span class="built_in">Task</span>(taskID);</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mymutex);</span><br><span class="line">		tasks.<span class="built_in">push_back</span>(pTask);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;produce a task, taskID: &quot;</span> &lt;&lt; taskID &lt;&lt; <span class="string">&quot;, threadID: &quot;</span></span><br><span class="line">			&lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mymutex);</span><br><span class="line">		<span class="built_in">pthread_cond_signal</span>(&amp;mycv);</span><br><span class="line">		taskID++;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mymutex, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_cond_init</span>(&amp;mycv, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> consumerThreadID[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="built_in">pthread_create</span>(&amp;consumerThreadID[i], <span class="literal">NULL</span>, consumer_thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> producerThreadID;</span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;producerThreadID, <span class="literal">NULL</span>, producer_thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_join</span>(producerThreadID, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="built_in">pthread_join</span>(consumerThreadID[i], <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_cond_destroy</span>(&amp;mycv);</span><br><span class="line">	<span class="built_in">pthread_mutex_destroy</span>(&amp;mymutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./5.png" alt="5"></p>
<ul>
<li><strong>条件变量的虚假唤醒</strong></li>
</ul>
<p>在写条件变量代码时判断条件变量醒来应用while而不是if，因为操作系统可能在某些情况下唤醒条件变量，存在没有其他线程向条件变量发送信号，但等待此条件变量的线程有可能醒来的情形。因此将条件放在一个while循环中意味着光唤醒条件变量不行，还必须满足条件，程序才能继续执行正常的逻辑。</p>
<ul>
<li><strong>条件变量信号丢失</strong></li>
</ul>
<p>如果条件变量信号在产生时调用了pthread_cond_signal或pthread_cond_broadcast，没有相关线程调用pthread_cond_wait捕获该信号，该信号就会永久丢失，再次调用就会导致永久阻塞。</p>
<h2 id="Linux读写锁"><a href="#Linux读写锁" class="headerlink" title="Linux读写锁"></a>Linux读写锁</h2><p>一般情况下线程只是读取共享变量的值，但如果要修改共享变量的值时，读请求之间无须同步，但是写请求时必须锁住读请求和其他写请求。</p>
<ul>
<li><strong>读写锁的应用方法</strong></li>
</ul>
<p>初始化和销毁API函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span>* attr)</span></span>;</span><br><span class="line"><span class="comment">//参数rwlock是读写锁的地址</span></span><br><span class="line"><span class="comment">//参数attr用于设置读写锁的属性，一般设置为NULL</span></span><br><span class="line"><span class="comment">//成功返回0，失败返回错误码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<p>如果不需要动态创建或者设置非默认属性的读写锁对象也可以利用如下语句初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_mt myrwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>读锁API函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock, <span class="keyword">const</span> struct timespec* abstime)</span></span>;</span><br><span class="line"><span class="comment">//该锁处于共享模式，如果当前读写锁已经被某线程以读模式占有，则其他线程请求时会立刻获得读锁</span></span><br><span class="line"><span class="comment">//如果当前读写锁已经被某线程以读模式占有，则其他线程请求写锁时会陷入阻塞</span></span><br></pre></td></tr></table></figure>

<p>写锁API函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock, <span class="keyword">const</span> struct timespec* abstime)</span></span>;</span><br><span class="line"><span class="comment">//如果当前读写锁被某线程以写模式占有，则无论读还是写都会被阻塞</span></span><br></pre></td></tr></table></figure>

<p>释放读锁或写锁API函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="comment">//成功获得读写锁返回0，失败返回错误码</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>读写锁的属性</strong></li>
</ul>
<p>pthread_rwlock_init的第二个参数可以设置读写锁的属性，pthread_rwlockattr_t。查询和修改读写锁的类型API函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_setkind_np</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span>* attr, <span class="keyword">int</span> pref)</span></span>;</span><br><span class="line"><span class="comment">//参数pref取值如下&quot;</span></span><br><span class="line"><span class="comment">//enum</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    读者优先（即同时请求读锁和写锁时，请求读锁的线程优先获得锁）</span></span><br><span class="line"><span class="comment">//    PTHREAD_RWLOCK_PREFER_READER_NP,</span></span><br><span class="line"><span class="comment">//    读者优先</span></span><br><span class="line"><span class="comment">//    PTHREAD_RWLOCK_PREFER_WRITER_NP,</span></span><br><span class="line"><span class="comment">//    写者优先（即同时请求读锁和写锁时，请求写锁的线程优先获得锁）</span></span><br><span class="line"><span class="comment">//    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,</span></span><br><span class="line"><span class="comment">//    PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READE_NP</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_getkind_np</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span>* attr, <span class="keyword">int</span>* pref)</span></span>;</span><br></pre></td></tr></table></figure>

<p>读写锁属性对象初始化和销毁API函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_init</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span>* attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlockattr_destroy</span><span class="params">(<span class="keyword">pthread_rwlockattr_t</span>* attr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>写着优先的读写锁代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_rwlockattr_t</span> attr;</span><br><span class="line"><span class="built_in">pthread_rwlockattr_init</span>(&amp;attr);</span><br><span class="line"><span class="built_in">pthread_rwlockattr_setkind_np</span>(&amp;attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);</span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, &amp;attr);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>读写锁实例</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> resourceID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> myrwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">read_thread</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pthread_rwlock_rdlock</span>(&amp;myrwlock);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;read thread ID: &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>()</span><br><span class="line">			&lt;&lt; <span class="string">&quot;, resourceID: &quot;</span> &lt;&lt; resourceID &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">pthread_rwlock_unlock</span>(&amp;myrwlock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">write_thread</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pthread_rwlock_wrlock</span>(&amp;myrwlock);</span><br><span class="line">		++resourceID;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;write thread ID: &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>()</span><br><span class="line">			&lt;&lt; <span class="string">&quot;, resourceID: &quot;</span> &lt;&lt; resourceID &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">pthread_rwlock_unlock</span>(&amp;myrwlock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_rwlock_init</span>(&amp;myrwlock, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> readThreadID[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="built_in">pthread_create</span>(&amp;readThreadID[i], <span class="literal">NULL</span>, read_thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> writeThreadID;</span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;writeThreadID, <span class="literal">NULL</span>, write_thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_join</span>(writeThreadID, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="built_in">pthread_join</span>(readThreadID[i], <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_rwlock_destroy</span>(&amp;myrwlock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./6.png" alt="6"></p>
<p>由于设置读写锁的属性是默认，即读锁线程优先获得锁，并且在读锁时会阻塞写锁线程，因此写锁线程很难获得锁。</p>
<p>修改读写锁属性为写优先：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> resourceID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> myrwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">read_thread</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pthread_rwlock_rdlock</span>(&amp;myrwlock);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;read thread ID: &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>()</span><br><span class="line">			&lt;&lt; <span class="string">&quot;, resourceID: &quot;</span> &lt;&lt; resourceID &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">pthread_rwlock_unlock</span>(&amp;myrwlock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">write_thread</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pthread_rwlock_wrlock</span>(&amp;myrwlock);</span><br><span class="line">		++resourceID;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;write thread ID: &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>()</span><br><span class="line">			&lt;&lt; <span class="string">&quot;, resourceID: &quot;</span> &lt;&lt; resourceID &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">pthread_rwlock_unlock</span>(&amp;myrwlock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_rwlockattr_t</span> attr;</span><br><span class="line">	<span class="built_in">pthread_rwlockattr_init</span>(&amp;attr);</span><br><span class="line">	<span class="built_in">pthread_rwlockattr_setkind_np</span>(&amp;attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);</span><br><span class="line">	<span class="built_in">pthread_rwlock_init</span>(&amp;myrwlock, &amp;attr);</span><br><span class="line">	<span class="keyword">pthread_t</span> readThreadID[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="built_in">pthread_create</span>(&amp;readThreadID[i], <span class="literal">NULL</span>, read_thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> writeThreadID;</span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;writeThreadID, <span class="literal">NULL</span>, write_thread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_join</span>(writeThreadID, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		<span class="built_in">pthread_join</span>(readThreadID[i], <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_rwlock_destroy</span>(&amp;myrwlock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./7.png" alt="7"></p>
<p>由于是写优先，可以看到wirte_thread明显增多</p>
<h2 id="C-11-14-17线程同步对象"><a href="#C-11-14-17线程同步对象" class="headerlink" title="C++ 11/14/17线程同步对象"></a>C++ 11/14/17线程同步对象</h2><ul>
<li>std::mutex系列</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/e444379edfaf4ca5a9fb64e7ec4e0176">Untitled</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_num = <span class="number">0</span>;</span><br><span class="line">std::mutex g_num_mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slow_increment</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		g_num_mutex.<span class="built_in">lock</span>();</span><br><span class="line">		++g_num;</span><br><span class="line">		std::cout &lt;&lt; id &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; g_num &lt;&lt; std::endl;</span><br><span class="line">		g_num_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(slow_increment, <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(slow_increment, <span class="number">1</span>)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./8.png" alt="8"></p>
<p>利用加锁解锁保护g_num</p>
<p>为了避免死锁std::mutex.lock和std::mutex::unlock方法需要成对使用。</p>
<h2 id="确保创建的线程一定能运行"><a href="#确保创建的线程一定能运行" class="headerlink" title="确保创建的线程一定能运行"></a>确保创建的线程一定能运行</h2><p>不仅需要判断线程创建函数是否调用成功，还要在线程函数中利用线程同步对象通知创建者线程是否创建成功。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex  mymutex;</span><br><span class="line">std::condition_variable mycv;</span><br><span class="line"><span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">		success = <span class="literal">true</span>;</span><br><span class="line">		mycv.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (!success)</span><br><span class="line">		&#123;</span><br><span class="line">			mycv.<span class="built_in">wait</span>(lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;start thread successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个新线程后会立即阻塞在一个条件变量上。工作线程成功运行起来，则会发送条件变量告知主线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mymutex;</span><br><span class="line">std::condition_variable mycv;</span><br><span class="line"><span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">int</span> no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">		success = <span class="literal">true</span>;</span><br><span class="line">		mycv.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;worker thread started, threadNO: &quot;</span> &lt;&lt; no &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;std::shared_ptr&lt;std::thread&gt;&gt; threads;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		success = <span class="literal">false</span>;</span><br><span class="line">		std::shared_ptr&lt;std::thread&gt; spthread;</span><br><span class="line">		spthread.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(thread_func, i));</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">			<span class="keyword">while</span> (!success)</span><br><span class="line">			&#123;</span><br><span class="line">				mycv.<span class="built_in">wait</span>(lock);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;start thread successfully, index: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">		threads.<span class="built_in">push_back</span>(spthread);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : threads)</span><br><span class="line">		iter-&gt;<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./9.png" alt="9"></p>
<p>创建一组线程时逐个创建，成功运行一个新线程后再创建下一个线程。</p>
<h2 id="多线程使用锁经验总结"><a href="#多线程使用锁经验总结" class="headerlink" title="多线程使用锁经验总结"></a>多线程使用锁经验总结</h2><ul>
<li><strong>减少锁的使用次数</strong></li>
</ul>
<p>加锁和解锁本身有一定的开销；临界区的代码不能并发执行；线程间对临界区的争夺太过激烈时，若线程竞争互斥体失败就会陷入阻塞并让出CPU。</p>
<ul>
<li><strong>明确锁的范围</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (my_hashtable.<span class="built_in">is_empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;my_mutex);</span><br><span class="line">	<span class="built_in">htable_insert</span>(my_hashtable, &amp;my_elem);</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;my_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码对my_hashtable插入操作使用了锁进行保护，但判断my_hashtable是否为空也需要使用锁进行保护所以正确为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;my_mutex);</span><br><span class="line"><span class="keyword">if</span>(my_hashtable.<span class="built_in">is_empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">htable_insert</span>(my_hashtable, &amp;elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mymutex);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>减少锁的使用粒度</strong></li>
</ul>
<p>尽量减少锁作用的临界区代码范围，临界区的代码范围越小，多个线程排队进入临界区的时间就会越短。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskPool::addTask</span><span class="params">(Task* task)</span></span>&#123;	std::lock_guard &lt; std::mutex&gt; <span class="built_in">guard</span>(m_mutexList);	std::shared_ptr&lt;Task&gt; spTask;	spTask.<span class="built_in">reset</span>(task);	m_taskList.<span class="built_in">push_back</span>(spTask);	m_cv.<span class="built_in">notify_one</span>();&#125;</span><br></pre></td></tr></table></figure>

<p>guard锁保护m_taskList，并且智能指针和唤醒线程没必要作为临界区的代码，修改如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskPool::addTask</span><span class="params">(Task* task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::shared_ptr&lt;Task&gt; spTask;</span><br><span class="line">  spTask.<span class="built_in">reset</span>(task);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_mutexList)</span></span>;</span><br><span class="line">    m_taskList.<span class="built_in">push_back</span>(spTask);</span><br><span class="line">  &#125;</span><br><span class="line">  m_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>guard锁仅对m_taskList.push_back()操作做保护</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_pendingFunctors.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		m_pendingFunctors[i]();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m_pendingFunctors是被锁保护的对象，类型为std::vector，必须等当前线程逐个处理完m_pendingFunctors中的元素后，其他线程才能操作m_pendingFunctors，修改如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;Functor&gt; localFunctors;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">		localFunctors.<span class="built_in">swap</span>(m_pendingFunctors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; localFunctors.<span class="built_in">size</span>(), ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		localFunctors[i]();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用了局部变量localFunctors，把m_pendingFunctors中的内容换到了localFunctors中，这样就释放锁并允许其他线程操作m_pendingFunctiors。</p>
<h1 id="线程池与队列系统的设计"><a href="#线程池与队列系统的设计" class="headerlink" title="线程池与队列系统的设计"></a>线程池与队列系统的设计</h1><h2 id="线程池的设计原理"><a href="#线程池的设计原理" class="headerlink" title="线程池的设计原理"></a>线程池的设计原理</h2><p>线程池是一组线程，在一些情况下需要异步执行一些任务，这些任务的产生和执行是存在于程序的整个生命周期内的。为了减少创建和销毁的开销，创建一组在程序生命周期内不会退出的线程是必要的，这些线程在拿到任务时运行，没有任务就处于阻塞或休眠状态。</p>
<p>一般来说，生命周期内产生的诸多的任务一般都被存放在队列中。队列的设计也是多种多样的，可以自由规定任务的读存方式或按照任务优先级等等方式进行队列的设计。</p>
<p>在队列的设计过程中，由于有非常多的线程都需要操作这个队列，所以一般来说需要对这个队列加锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*     TaskPool.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;handle a task&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Task</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;a task destructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskPool</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TaskPool</span>();</span><br><span class="line">	~<span class="built_in">TaskPool</span>();</span><br><span class="line">	<span class="built_in">TaskPool</span>(<span class="keyword">const</span> TaskPool&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">	TaskPool&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> TaskPool&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> threadNum = <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Task* task)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeAllTasks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">threadFunc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::list&lt;std::shared_ptr&lt;Task&gt;&gt;			m_taskList;</span><br><span class="line">	std::mutex									m_mutexList;</span><br><span class="line">	std::condition_variable						m_cv;</span><br><span class="line">	<span class="keyword">bool</span>										m_bRunning;</span><br><span class="line">	std::vector &lt;std::shared_ptr&lt;std::thread&gt;&gt;	m_threads;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*     TaskPool.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TaskPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskPool::<span class="built_in">TaskPool</span>() : <span class="built_in">m_bRunning</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskPool::~<span class="built_in">TaskPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">removeAllTasks</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskPool::init</span><span class="params">(<span class="keyword">int</span> threadNum<span class="comment">/* = 5*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (threadNum &lt;= <span class="number">0</span>)</span><br><span class="line">		threadNum = <span class="number">5</span>;</span><br><span class="line">	m_bRunning = <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		std::shared_ptr&lt;std::thread&gt; spThread;</span><br><span class="line">		spThread.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;TaskPool::threadFunc, <span class="keyword">this</span>)));</span><br><span class="line">		m_threads.<span class="built_in">push_back</span>(spThread);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskPool::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::shared_ptr&lt;Task&gt; spTask;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//减小guard锁的作用范围</span></span><br><span class="line">			<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_mutexList)</span></span>;</span><br><span class="line">			<span class="keyword">while</span> (m_taskList.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!m_bRunning)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//如果获得了互斥锁，但是条件不满足，</span></span><br><span class="line">				<span class="comment">//则m_cv.wait()调用会释放锁，且挂起当前线程，因此不往下执行</span></span><br><span class="line">				<span class="comment">//条件满足时m_cv.wait()将唤醒挂起的线程并且获得锁</span></span><br><span class="line">				m_cv.<span class="built_in">wait</span>(guard);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!m_bRunning)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			spTask = m_taskList.<span class="built_in">front</span>();</span><br><span class="line">			m_taskList.<span class="built_in">pop_front</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (spTask == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		spTask-&gt;<span class="built_in">doIt</span>();</span><br><span class="line">		spTask.<span class="built_in">reset</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;exit thread, threadID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskPool::stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_bRunning = <span class="literal">false</span>;</span><br><span class="line">	m_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">	<span class="comment">//等待所有线程退出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : m_threads)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (iter-&gt;<span class="built_in">joinable</span>())</span><br><span class="line">			iter-&gt;<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskPool::addTask</span><span class="params">(Task* task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::shared_ptr&lt;Task&gt; spTask;</span><br><span class="line">	spTask.<span class="built_in">reset</span>(task);</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_mutexList)</span></span>;</span><br><span class="line">		m_taskList.<span class="built_in">push_back</span>(spTask);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;add a Task&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskPool::removeAllTasks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_mutexList)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; iter : m_taskList)</span><br><span class="line">			iter.<span class="built_in">reset</span>();</span><br><span class="line">		m_taskList.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*     Main.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TaskPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TaskPool threadPool;</span><br><span class="line">	threadPool.<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">	Task* task = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		task = <span class="keyword">new</span> <span class="built_in">Task</span>();</span><br><span class="line">		threadPool.<span class="built_in">addTask</span>(task);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">	threadPool.<span class="built_in">stop</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./%E5%A4%9A%E7%BA%BF%E7%A8%8B-1.png" alt="多线程-1"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/04/MYSQL-aliTask1/" rel="next" title="天池mysql练习TASK1">
                <i class="fa fa-chevron-left"></i> 天池mysql练习TASK1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/04/MYSQL-aliTask2/" rel="prev" title="MYSQL-aliTask2">
                MYSQL-aliTask2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">线程、进程基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">线程的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%88Linux%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">创建线程（Linux）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%88Windows%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">创建线程（Windows）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%88Windows-CRT%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">创建线程（Windows CRT）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%88std-thread"><span class="nav-number">2.4.</span> <span class="nav-text">创建线程（std::thread)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8BID"><span class="nav-number">2.5.</span> <span class="nav-text">获取线程ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="nav-number">2.6.</span> <span class="nav-text">等待线程结束</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">对象实例指针作为线程函数的参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">整型变量的原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="nav-number">4.1.</span> <span class="nav-text">原子操作与整型变量的赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11%E5%AF%B9%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">4.2.</span> <span class="nav-text">C++11对整型变量原子操作的支持</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text">Linux线程同步对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E4%BA%92%E6%96%A5%E4%BD%93"><span class="nav-number">5.1.</span> <span class="nav-text">Linux互斥体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">5.2.</span> <span class="nav-text">Linux信号量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">5.3.</span> <span class="nav-text">Linux条件变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">5.4.</span> <span class="nav-text">Linux读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-14-17%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.5.</span> <span class="nav-text">C++ 11&#x2F;14&#x2F;17线程同步对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AE%E4%BF%9D%E5%88%9B%E5%BB%BA%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%80%E5%AE%9A%E8%83%BD%E8%BF%90%E8%A1%8C"><span class="nav-number">5.6.</span> <span class="nav-text">确保创建的线程一定能运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E9%94%81%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93"><span class="nav-number">5.7.</span> <span class="nav-text">多线程使用锁经验总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.</span> <span class="nav-text">线程池与队列系统的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="nav-number">6.1.</span> <span class="nav-text">线程池的设计原理</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">巨鹏辉</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
